Min Gahramanova U29579643 
Program Description Document 


Welcome to the brain-teaser simulator program. This program features five different mini-games, namely, Bagels, Tower of Hanoi, Hangman, Treasure Hunt, and Tic-Tac-Toe. All the interaction with the user is performed graphically through the console. 
Once the user runs the driver program (main.cpp), the would be prompted with six different choices, where choices 1 - 5 stand for their respective games, and choice 6 allows to quit the program. The program runs repeatedly, allowing to select a different game on each iteration, until the user chooses to quit by selecting option 6.
The first option corresponds leads you to the Bagels subprogram, which is a simple number number-guessing game. Here, the computer generates a random N-digit number (3 by default) which all consists of unique digits only. The user then must guess the number in a limited number of attempts (9 by default), and the number of remaining lives reduces with each incorrect response. With each one of user guesses, the computer displays several clues of different clues. The clue 'Pico' corresponds to guessing a correct digit, but in a spot different from the one in secret umber. The clue 'Fermi' corresponds to correctly guessing both a digit and a spot. If neither any digits nor their positions were guessed, the clues are ''Bagels''. Each guess can yield multiple clues; for example, if the secret number is 426 and the user enters 621, the clues are 'Pico Fermi', since 6 was guessed but in a wrong position, and 2 was correct in both the digit and the position. A round of the game completes once the user guesses the number or runs out of allowed attempts. 
Choice number 2 corresponds to the Hangman game, which is a word-guessing classic everyone is probably familiar with. In this game, the computer picks a random number and allows the user to guess it letter-by-letter. We start off with all the letters in the word being covered, showing the user only the total number if letters in the word. If a letter entered by the user is present tin the word, it is being uncovered in all positions. If the guessed letter is incorrect, on the other hand, we decrement the number of remaining lives and display the corresponding Hangman graphic. The game ends when the user either guesses the word in its entirety or runs out of all allotted lives. 
Choice number 3 corresponds to the Tic-Tac-Toe game, another timeless classic. In this game, the user would be battling against the computer (as opposed to another person, as it is done normally). The game board represents a nine-slot grid, and the objective is to fill a row, column, or diagonal with your symbol before your opponent has the opportunity of doing so. The user can choose a symbol of their preference (either x or o), after which the game begins. The user chooses a slot by entering its corresponding index (0-8 inclusive), after which the computer makes its move. The game ends once a row, column, or a diagonal is filled with the same symbol, or when the board is full, which results in a tie.
Choice 4 corresponds to the game of Treasure hunt, which is a map-based searching game similar to Battleship. The computer first generates a map of desired dimensions, and then picks several random locations for the 'hidden chests'.  The goal is for the user to be able to locate all the hidden treasure chests by dropping 'sonar devices' at specific locations on the map. If a sonar device land sufficiently close to one of the chests, then the map displays the distance between the said device and the chest. The game ends once the user uncovers all the hidden chests or runs out of sonar devices. 
Lastly, option number 5 corresponds to the ancient puzzle called the Tower of Hanoi. In this puzzle, the user is presented with three pegs ('towers') with a specified number of different sizes. We start off by placing all disks on the first tower in the order form largest to smallest. In this version, each tower is represented as a printed row, and each disk - a capital letter. A larger disk corresponds to a letter later in the alphabet (i.e. disk B would be larger than disc A etc). The goal is to move all the disks to tower 3, leaving towers 1 and 2 empty. The challenging part is that the user is allowed to only make one move at a time, and this move should never result in a disk of a larger size being placed on top of a disk of a smaller size. The game ends once the user manages to properly displace all of the initial disks. 
 
Functionally, the code for the program is quite modular, as each game is represented as a separate class. This implies that each game is still playable outside this program, and that it would be quite easy to expand it to include more games. 
Each of the game classes in the program (i.e. Bagels.h, Hangman.h, TreasureHunt.h, TicTacToe.h and Hanoi.h ) share similar functionalities, and are therefore all derived from an abstract base class Game, making use of the perks of class inheritance. This class defined pure virtual functions for running a round of the game, displaying the current state, and displaying the menu, which all would be overridden accordingly in their respective classes. The game class also provides each of its children with a utility method that manages whether the user would be willing to play another round. 
The crux of the first game, Bagels, is contained within two classes - BaglesGuess and Bagels. BagelsGuess represents the user's current guess regarding the secret number. This class mainly ensures that the user's guess is valid by checking whether is has a correct number of digits and does not feature any duplicate digits. It also makes sure that the user does not re-enter a number that they have already mentioned earlier. 
The overarching functionality of the game is provided by the Bagels class. In addition to its basic functionalities (play, display and show description), this class manages the generation of a random number with a satisfactory number of digits and no duplicates. The class also manages all the user interactions, prompting them for a guess, checking its validity (with the help of its BagelsGuess member), and displacing the appropriate clues. The game loop iterates again and again until the user either guesses the correct number or runs out of all lives. 
All the functionalities of the Hangman game are contained within the Hangman class and its constituent HangBoard, HangPlayer, and WordGenerator classes. The HangBoard class is in charge of the graphic representation of each round of the game and its timely updating. It displays the users current progress in guessing the word, as well as the corresponding ASCII graphics. This class also keeps track of the user's remaining lives and checks whether the game is over at the end of each I/O iteration. To allow the Hangman class access to customizing the allowed number of lives and ASCII graphics, this class defriends the Hangman class.
The HangPlayer class oversees checking user input and ensuring that each entered character presents a valid guess. It also notifies the user if a certain letter has already been used and subtracts a life if the guess s invalid. 
The WordGenerator class is in charge of generating a random word for the user to guess on each round of the game. It allows the main program to read in words form a desired file and store them in a vector of strings. Since word generation is not a property particular to a single class instance, WordGenerator makes its methods and members static. 
Finally, the Hangman class is an accumulation of the Board, Player, and WordGenerator lasses, ensuring smooth running of each run of the game. On each iteration, it accepts user input, updates board state, displays progress, and checks whether the game is over. 
He TicTaccToe game is correspondingly represented by the TicTacToe class an its respective Board an Player classes. 
Since we essentially need two players for this game - the computer and the user, which exhibit slightly differing capabilities, we make the class TicTacToePlayer abstract and derive the more specific TicTacToePlayerPerson ad TicTacToePlayerComputer classes. Person and Computer Player classes override the virtual function for generating a move. The user's move is simply accepted through the console as an index if the desired slot. Computer moves, on the other hand, are generated using a simple algorithm. This algorithm first checks if the computer can win with the next move, and if not, it blocks a potential future winning move for the user. If neither of those conditions are true, the computer just picks a random remaining slot.  
The TicTacToeBoard class manages the graphic representation of the game's classic nine-cell grid and updates it with each move. The board is stored as a two-dimensional vector of three-character vectors. It also provides an overloaded array indexing operator to allow for easier access to the underlying grid. 
The TicTacToe class accumulates all the constituent parts of the game, including two types of players and the board. The game loop provided by the class makes use of polymorphism to simplify. The Computer and Person Player classes are stored in a base-class pointer of the TicTacToePlayer type. On each iteration, when we attempt to get a move from the Player handle, we can expect to run the correct specialized version of the method. 
The Treasure game is managed by its corresponding TreasureHunt class, which is composed of a TreasureBoard class to represent the graphics, as well as a vector of Point objects with the locations of chests and sonar devices. The Point class allows us to easily represent the locations of sonar devices and treasure chests using Cartesian coordinates. It also provides us with a method for calculating the distance between two points on the map. The TreasureBoard class stores the graphical representation of the map within a two-dimensional vector of characters with specified dimensions. It also allows is to validate user's moves and update the board accordingly. The TreasureHunt class accumulates all these functionalities and manages user input ad its validation. It also contains a function for generating random chest locations and disseminating them throughout the map. 
Lastly, the functionalities of the Power of Hanoi puzzle are provided by the corresponding Hanoi class and its array of Tower objects. The Tower class represent a single tower in the game, storing its current disks and allowing to accept/remove new ones. The disks are simply represented by capital letters, where a smaller disk comes earlier in the alphabet, allowing to compare them using regular arithmetic comparison operators. The Tower class also provides and overloaded compound addition operator, which makes it easier to 'push' a new disk on top. 
The Hanoi class oversees accepting user input, moving disks from tower to tower, and displaying the results of the user. It checks of a move is valid and completes the game once all towers have been moved from to first tower to the second one. 

